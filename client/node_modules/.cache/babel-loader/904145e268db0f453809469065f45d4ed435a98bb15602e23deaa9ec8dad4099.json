{"ast":null,"code":"/**\n *\n * server\n *\n */\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n    i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\nexport function makeServer(options) {\n  const {\n    schema,\n    context,\n    roots,\n    validate,\n    execute,\n    subscribe,\n    connectionInitWaitTimeout = 3000,\n    // 3 seconds\n    onConnect,\n    onDisconnect,\n    onClose,\n    onSubscribe,\n    onOperation,\n    onNext,\n    onError,\n    onComplete,\n    jsonMessageReviver: reviver,\n    jsonMessageReplacer: replacer\n  } = options;\n  return {\n    opened(socket, extra) {\n      const ctx = {\n        connectionInitReceived: false,\n        acknowledged: false,\n        subscriptions: {},\n        extra\n      };\n      if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n        socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n        return async (code, reason) => {\n          /* nothing was set up, just notify the closure */\n          await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n        };\n      }\n      // kick the client off (close socket) if the connection has\n      // not been initialised after the specified wait timeout\n      const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout) ? setTimeout(() => {\n        if (!ctx.connectionInitReceived) socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n      }, connectionInitWaitTimeout) : null;\n      socket.onMessage(async function onMessage(data) {\n        var e_1, _a;\n        var _b;\n        let message;\n        try {\n          message = parseMessage(data, reviver);\n        } catch (err) {\n          return socket.close(CloseCode.BadRequest, 'Invalid message received');\n        }\n        switch (message.type) {\n          case MessageType.ConnectionInit:\n            {\n              if (ctx.connectionInitReceived) return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n              // @ts-expect-error: I can write\n              ctx.connectionInitReceived = true;\n              if (isObject(message.payload))\n                // @ts-expect-error: I can write\n                ctx.connectionParams = message.payload;\n              const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n              if (permittedOrPayload === false) return socket.close(CloseCode.Forbidden, 'Forbidden');\n              await socket.send(stringifyMessage(isObject(permittedOrPayload) ? {\n                type: MessageType.ConnectionAck,\n                payload: permittedOrPayload\n              } : {\n                type: MessageType.ConnectionAck\n                // payload is completely absent if not provided\n              }, replacer));\n              // @ts-expect-error: I can write\n              ctx.acknowledged = true;\n              return;\n            }\n          case MessageType.Ping:\n            {\n              if (socket.onPing)\n                // if the onPing listener is registered, automatic pong is disabled\n                return await socket.onPing(message.payload);\n              await socket.send(stringifyMessage(message.payload ? {\n                type: MessageType.Pong,\n                payload: message.payload\n              } : {\n                type: MessageType.Pong\n                // payload is completely absent if not provided\n              }));\n\n              return;\n            }\n          case MessageType.Pong:\n            return await ((_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload));\n          case MessageType.Subscribe:\n            {\n              if (!ctx.acknowledged) return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n              const {\n                id,\n                payload\n              } = message;\n              if (id in ctx.subscriptions) return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n              // if this turns out to be a streaming operation, the subscription value\n              // will change to an `AsyncIterable`, otherwise it will stay as is\n              ctx.subscriptions[id] = null;\n              const emit = {\n                next: async (result, args) => {\n                  let nextMessage = {\n                    id,\n                    type: MessageType.Next,\n                    payload: result\n                  };\n                  const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                  if (maybeResult) nextMessage = Object.assign(Object.assign({}, nextMessage), {\n                    payload: maybeResult\n                  });\n                  await socket.send(stringifyMessage(nextMessage, replacer));\n                },\n                error: async errors => {\n                  let errorMessage = {\n                    id,\n                    type: MessageType.Error,\n                    payload: errors\n                  };\n                  const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                  if (maybeErrors) errorMessage = Object.assign(Object.assign({}, errorMessage), {\n                    payload: maybeErrors\n                  });\n                  await socket.send(stringifyMessage(errorMessage, replacer));\n                },\n                complete: async notifyClient => {\n                  const completeMessage = {\n                    id,\n                    type: MessageType.Complete\n                  };\n                  await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                  if (notifyClient) await socket.send(stringifyMessage(completeMessage, replacer));\n                }\n              };\n              try {\n                let execArgs;\n                const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                if (maybeExecArgsOrErrors) {\n                  if (areGraphQLErrors(maybeExecArgsOrErrors)) return await emit.error(maybeExecArgsOrErrors);else if (Array.isArray(maybeExecArgsOrErrors)) throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                  // not errors, is exec args\n                  execArgs = maybeExecArgsOrErrors;\n                } else {\n                  // you either provide a schema dynamically through\n                  // `onSubscribe` or you set one up during the server setup\n                  if (!schema) throw new Error('The GraphQL schema is not provided');\n                  const args = {\n                    operationName: payload.operationName,\n                    document: parse(payload.query),\n                    variableValues: payload.variables\n                  };\n                  execArgs = Object.assign(Object.assign({}, args), {\n                    schema: typeof schema === 'function' ? await schema(ctx, message, args) : schema\n                  });\n                  const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                  if (validationErrors.length > 0) return await emit.error(validationErrors);\n                }\n                const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                if (!operationAST) return await emit.error([new GraphQLError('Unable to identify operation')]);\n                // if `onSubscribe` didnt specify a rootValue, inject one\n                if (!('rootValue' in execArgs)) execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                // if `onSubscribe` didn't specify a context, inject one\n                if (!('contextValue' in execArgs)) execArgs.contextValue = typeof context === 'function' ? await context(ctx, message, execArgs) : context;\n                // the execution arguments have been prepared\n                // perform the operation and act accordingly\n                let operationResult;\n                if (operationAST.operation === 'subscription') operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                // operation === 'query' || 'mutation'\n                else operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                if (maybeResult) operationResult = maybeResult;\n                if (isAsyncIterable(operationResult)) {\n                  /** multiple emitted results */\n                  if (!(id in ctx.subscriptions)) {\n                    // subscription was completed/canceled before the operation settled\n                    if (isAsyncGenerator(operationResult)) operationResult.return(undefined);\n                  } else {\n                    ctx.subscriptions[id] = operationResult;\n                    try {\n                      for (var operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), !operationResult_1_1.done;) {\n                        const result = operationResult_1_1.value;\n                        await emit.next(result, execArgs);\n                      }\n                    } catch (e_1_1) {\n                      e_1 = {\n                        error: e_1_1\n                      };\n                    } finally {\n                      try {\n                        if (operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return)) await _a.call(operationResult_1);\n                      } finally {\n                        if (e_1) throw e_1.error;\n                      }\n                    }\n                  }\n                } else {\n                  /** single emitted result */\n                  // if the client completed the subscription before the single result\n                  // became available, he effectively canceled it and no data should be sent\n                  if (id in ctx.subscriptions) await emit.next(operationResult, execArgs);\n                }\n                // lack of subscription at this point indicates that the client\n                // completed the subscription, he doesnt need to be reminded\n                await emit.complete(id in ctx.subscriptions);\n              } finally {\n                // whatever happens to the subscription, we finally want to get rid of the reservation\n                delete ctx.subscriptions[id];\n              }\n              return;\n            }\n          case MessageType.Complete:\n            {\n              const subscription = ctx.subscriptions[message.id];\n              delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n              if (isAsyncGenerator(subscription)) await subscription.return(undefined);\n              return;\n            }\n          default:\n            throw new Error(`Unexpected message of type ${message.type} received`);\n        }\n      });\n      // wait for close, cleanup and the disconnect callback\n      return async (code, reason) => {\n        if (connectionInitWait) clearTimeout(connectionInitWait);\n        for (const sub of Object.values(ctx.subscriptions)) {\n          if (isAsyncGenerator(sub)) await sub.return(undefined);\n        }\n        if (ctx.acknowledged) await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n        await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n      };\n    }\n  };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n  switch (true) {\n    case protocols instanceof Set && protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case Array.isArray(protocols) && protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n    case typeof protocols === 'string' && protocols.split(',').map(p => p.trim()).includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n      return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    default:\n      return false;\n  }\n}","map":{"version":3,"names":["__asyncValues","o","Symbol","asyncIterator","TypeError","m","i","call","__values","iterator","verb","n","v","Promise","resolve","reject","settle","done","value","d","then","parse","validate","graphqlValidate","execute","graphqlExecute","subscribe","graphqlSubscribe","getOperationAST","GraphQLError","GRAPHQL_TRANSPORT_WS_PROTOCOL","CloseCode","MessageType","stringifyMessage","parseMessage","isObject","isAsyncGenerator","isAsyncIterable","areGraphQLErrors","makeServer","options","schema","context","roots","connectionInitWaitTimeout","onConnect","onDisconnect","onClose","onSubscribe","onOperation","onNext","onError","onComplete","jsonMessageReviver","reviver","jsonMessageReplacer","replacer","opened","socket","extra","ctx","connectionInitReceived","acknowledged","subscriptions","protocol","close","SubprotocolNotAcceptable","code","reason","connectionInitWait","isFinite","setTimeout","ConnectionInitialisationTimeout","onMessage","data","e_1","_a","_b","message","err","BadRequest","type","ConnectionInit","TooManyInitialisationRequests","payload","connectionParams","permittedOrPayload","Forbidden","send","ConnectionAck","Ping","onPing","Pong","onPong","Subscribe","Unauthorized","id","SubscriberAlreadyExists","emit","next","result","args","nextMessage","Next","maybeResult","Object","assign","error","errors","errorMessage","Error","maybeErrors","complete","notifyClient","completeMessage","Complete","execArgs","maybeExecArgsOrErrors","Array","isArray","operationName","document","query","variableValues","variables","validationErrors","length","operationAST","rootValue","operation","contextValue","operationResult","return","undefined","operationResult_1","operationResult_1_1","e_1_1","subscription","clearTimeout","sub","values","handleProtocols","protocols","Set","has","includes","split","map","p","trim"],"sources":["/Users/manojkumars/Documents/graphql_chat/client/node_modules/graphql-ws/lib/server.mjs"],"sourcesContent":["/**\n *\n * server\n *\n */\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { parse, validate as graphqlValidate, execute as graphqlExecute, subscribe as graphqlSubscribe, getOperationAST, GraphQLError, } from 'graphql';\nimport { GRAPHQL_TRANSPORT_WS_PROTOCOL, CloseCode, MessageType, stringifyMessage, parseMessage, } from './common.mjs';\nimport { isObject, isAsyncGenerator, isAsyncIterable, areGraphQLErrors, } from './utils.mjs';\n/**\n * Makes a Protocol complient WebSocket GraphQL server. The server\n * is actually an API which is to be used with your favourite WebSocket\n * server library!\n *\n * Read more about the Protocol in the PROTOCOL.md documentation file.\n *\n * @category Server\n */\nexport function makeServer(options) {\n    const { schema, context, roots, validate, execute, subscribe, connectionInitWaitTimeout = 3000, // 3 seconds\n    onConnect, onDisconnect, onClose, onSubscribe, onOperation, onNext, onError, onComplete, jsonMessageReviver: reviver, jsonMessageReplacer: replacer, } = options;\n    return {\n        opened(socket, extra) {\n            const ctx = {\n                connectionInitReceived: false,\n                acknowledged: false,\n                subscriptions: {},\n                extra,\n            };\n            if (socket.protocol !== GRAPHQL_TRANSPORT_WS_PROTOCOL) {\n                socket.close(CloseCode.SubprotocolNotAcceptable, 'Subprotocol not acceptable');\n                return async (code, reason) => {\n                    /* nothing was set up, just notify the closure */\n                    await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n                };\n            }\n            // kick the client off (close socket) if the connection has\n            // not been initialised after the specified wait timeout\n            const connectionInitWait = connectionInitWaitTimeout > 0 && isFinite(connectionInitWaitTimeout)\n                ? setTimeout(() => {\n                    if (!ctx.connectionInitReceived)\n                        socket.close(CloseCode.ConnectionInitialisationTimeout, 'Connection initialisation timeout');\n                }, connectionInitWaitTimeout)\n                : null;\n            socket.onMessage(async function onMessage(data) {\n                var e_1, _a;\n                var _b;\n                let message;\n                try {\n                    message = parseMessage(data, reviver);\n                }\n                catch (err) {\n                    return socket.close(CloseCode.BadRequest, 'Invalid message received');\n                }\n                switch (message.type) {\n                    case MessageType.ConnectionInit: {\n                        if (ctx.connectionInitReceived)\n                            return socket.close(CloseCode.TooManyInitialisationRequests, 'Too many initialisation requests');\n                        // @ts-expect-error: I can write\n                        ctx.connectionInitReceived = true;\n                        if (isObject(message.payload))\n                            // @ts-expect-error: I can write\n                            ctx.connectionParams = message.payload;\n                        const permittedOrPayload = await (onConnect === null || onConnect === void 0 ? void 0 : onConnect(ctx));\n                        if (permittedOrPayload === false)\n                            return socket.close(CloseCode.Forbidden, 'Forbidden');\n                        await socket.send(stringifyMessage(isObject(permittedOrPayload)\n                            ? {\n                                type: MessageType.ConnectionAck,\n                                payload: permittedOrPayload,\n                            }\n                            : {\n                                type: MessageType.ConnectionAck,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        // @ts-expect-error: I can write\n                        ctx.acknowledged = true;\n                        return;\n                    }\n                    case MessageType.Ping: {\n                        if (socket.onPing)\n                            // if the onPing listener is registered, automatic pong is disabled\n                            return await socket.onPing(message.payload);\n                        await socket.send(stringifyMessage(message.payload\n                            ? { type: MessageType.Pong, payload: message.payload }\n                            : {\n                                type: MessageType.Pong,\n                                // payload is completely absent if not provided\n                            }));\n                        return;\n                    }\n                    case MessageType.Pong:\n                        return await ((_b = socket.onPong) === null || _b === void 0 ? void 0 : _b.call(socket, message.payload));\n                    case MessageType.Subscribe: {\n                        if (!ctx.acknowledged)\n                            return socket.close(CloseCode.Unauthorized, 'Unauthorized');\n                        const { id, payload } = message;\n                        if (id in ctx.subscriptions)\n                            return socket.close(CloseCode.SubscriberAlreadyExists, `Subscriber for ${id} already exists`);\n                        // if this turns out to be a streaming operation, the subscription value\n                        // will change to an `AsyncIterable`, otherwise it will stay as is\n                        ctx.subscriptions[id] = null;\n                        const emit = {\n                            next: async (result, args) => {\n                                let nextMessage = {\n                                    id,\n                                    type: MessageType.Next,\n                                    payload: result,\n                                };\n                                const maybeResult = await (onNext === null || onNext === void 0 ? void 0 : onNext(ctx, nextMessage, args, result));\n                                if (maybeResult)\n                                    nextMessage = Object.assign(Object.assign({}, nextMessage), { payload: maybeResult });\n                                await socket.send(stringifyMessage(nextMessage, replacer));\n                            },\n                            error: async (errors) => {\n                                let errorMessage = {\n                                    id,\n                                    type: MessageType.Error,\n                                    payload: errors,\n                                };\n                                const maybeErrors = await (onError === null || onError === void 0 ? void 0 : onError(ctx, errorMessage, errors));\n                                if (maybeErrors)\n                                    errorMessage = Object.assign(Object.assign({}, errorMessage), { payload: maybeErrors });\n                                await socket.send(stringifyMessage(errorMessage, replacer));\n                            },\n                            complete: async (notifyClient) => {\n                                const completeMessage = {\n                                    id,\n                                    type: MessageType.Complete,\n                                };\n                                await (onComplete === null || onComplete === void 0 ? void 0 : onComplete(ctx, completeMessage));\n                                if (notifyClient)\n                                    await socket.send(stringifyMessage(completeMessage, replacer));\n                            },\n                        };\n                        try {\n                            let execArgs;\n                            const maybeExecArgsOrErrors = await (onSubscribe === null || onSubscribe === void 0 ? void 0 : onSubscribe(ctx, message));\n                            if (maybeExecArgsOrErrors) {\n                                if (areGraphQLErrors(maybeExecArgsOrErrors))\n                                    return await emit.error(maybeExecArgsOrErrors);\n                                else if (Array.isArray(maybeExecArgsOrErrors))\n                                    throw new Error('Invalid return value from onSubscribe hook, expected an array of GraphQLError objects');\n                                // not errors, is exec args\n                                execArgs = maybeExecArgsOrErrors;\n                            }\n                            else {\n                                // you either provide a schema dynamically through\n                                // `onSubscribe` or you set one up during the server setup\n                                if (!schema)\n                                    throw new Error('The GraphQL schema is not provided');\n                                const args = {\n                                    operationName: payload.operationName,\n                                    document: parse(payload.query),\n                                    variableValues: payload.variables,\n                                };\n                                execArgs = Object.assign(Object.assign({}, args), { schema: typeof schema === 'function'\n                                        ? await schema(ctx, message, args)\n                                        : schema });\n                                const validationErrors = (validate !== null && validate !== void 0 ? validate : graphqlValidate)(execArgs.schema, execArgs.document);\n                                if (validationErrors.length > 0)\n                                    return await emit.error(validationErrors);\n                            }\n                            const operationAST = getOperationAST(execArgs.document, execArgs.operationName);\n                            if (!operationAST)\n                                return await emit.error([\n                                    new GraphQLError('Unable to identify operation'),\n                                ]);\n                            // if `onSubscribe` didnt specify a rootValue, inject one\n                            if (!('rootValue' in execArgs))\n                                execArgs.rootValue = roots === null || roots === void 0 ? void 0 : roots[operationAST.operation];\n                            // if `onSubscribe` didn't specify a context, inject one\n                            if (!('contextValue' in execArgs))\n                                execArgs.contextValue =\n                                    typeof context === 'function'\n                                        ? await context(ctx, message, execArgs)\n                                        : context;\n                            // the execution arguments have been prepared\n                            // perform the operation and act accordingly\n                            let operationResult;\n                            if (operationAST.operation === 'subscription')\n                                operationResult = await (subscribe !== null && subscribe !== void 0 ? subscribe : graphqlSubscribe)(execArgs);\n                            // operation === 'query' || 'mutation'\n                            else\n                                operationResult = await (execute !== null && execute !== void 0 ? execute : graphqlExecute)(execArgs);\n                            const maybeResult = await (onOperation === null || onOperation === void 0 ? void 0 : onOperation(ctx, message, execArgs, operationResult));\n                            if (maybeResult)\n                                operationResult = maybeResult;\n                            if (isAsyncIterable(operationResult)) {\n                                /** multiple emitted results */\n                                if (!(id in ctx.subscriptions)) {\n                                    // subscription was completed/canceled before the operation settled\n                                    if (isAsyncGenerator(operationResult))\n                                        operationResult.return(undefined);\n                                }\n                                else {\n                                    ctx.subscriptions[id] = operationResult;\n                                    try {\n                                        for (var operationResult_1 = __asyncValues(operationResult), operationResult_1_1; operationResult_1_1 = await operationResult_1.next(), !operationResult_1_1.done;) {\n                                            const result = operationResult_1_1.value;\n                                            await emit.next(result, execArgs);\n                                        }\n                                    }\n                                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                                    finally {\n                                        try {\n                                            if (operationResult_1_1 && !operationResult_1_1.done && (_a = operationResult_1.return)) await _a.call(operationResult_1);\n                                        }\n                                        finally { if (e_1) throw e_1.error; }\n                                    }\n                                }\n                            }\n                            else {\n                                /** single emitted result */\n                                // if the client completed the subscription before the single result\n                                // became available, he effectively canceled it and no data should be sent\n                                if (id in ctx.subscriptions)\n                                    await emit.next(operationResult, execArgs);\n                            }\n                            // lack of subscription at this point indicates that the client\n                            // completed the subscription, he doesnt need to be reminded\n                            await emit.complete(id in ctx.subscriptions);\n                        }\n                        finally {\n                            // whatever happens to the subscription, we finally want to get rid of the reservation\n                            delete ctx.subscriptions[id];\n                        }\n                        return;\n                    }\n                    case MessageType.Complete: {\n                        const subscription = ctx.subscriptions[message.id];\n                        delete ctx.subscriptions[message.id]; // deleting the subscription means no further activity should take place\n                        if (isAsyncGenerator(subscription))\n                            await subscription.return(undefined);\n                        return;\n                    }\n                    default:\n                        throw new Error(`Unexpected message of type ${message.type} received`);\n                }\n            });\n            // wait for close, cleanup and the disconnect callback\n            return async (code, reason) => {\n                if (connectionInitWait)\n                    clearTimeout(connectionInitWait);\n                for (const sub of Object.values(ctx.subscriptions)) {\n                    if (isAsyncGenerator(sub))\n                        await sub.return(undefined);\n                }\n                if (ctx.acknowledged)\n                    await (onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect(ctx, code, reason));\n                await (onClose === null || onClose === void 0 ? void 0 : onClose(ctx, code, reason));\n            };\n        },\n    };\n}\n/**\n * Helper utility for choosing the \"graphql-transport-ws\" subprotocol from\n * a set of WebSocket subprotocols.\n *\n * Accepts a set of already extracted WebSocket subprotocols or the raw\n * Sec-WebSocket-Protocol header value. In either case, if the right\n * protocol appears, it will be returned.\n *\n * By specification, the server should not provide a value with Sec-WebSocket-Protocol\n * if it does not agree with client's subprotocols. The client has a responsibility\n * to handle the connection afterwards.\n *\n * @category Server\n */\nexport function handleProtocols(protocols) {\n    switch (true) {\n        case protocols instanceof Set &&\n            protocols.has(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case Array.isArray(protocols) &&\n            protocols.includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n        case typeof protocols === 'string' &&\n            protocols\n                .split(',')\n                .map((p) => p.trim())\n                .includes(GRAPHQL_TRANSPORT_WS_PROTOCOL):\n            return GRAPHQL_TRANSPORT_WS_PROTOCOL;\n        default:\n            return false;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}